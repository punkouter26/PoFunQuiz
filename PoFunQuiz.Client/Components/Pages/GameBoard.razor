@page "/game-board"
@using PoFunQuiz.Client
@using PoFunQuiz.Core.Services
@using PoFunQuiz.Core.Models
@using System.Timers
@using System.Diagnostics
@using Radzen
@using Radzen.Blazor
@inject NavigationManager Navigation
@inject PoFunQuiz.Client.GameState GameState
@inject IJSRuntime JS
@inject ILogger<GameBoard> Logger
@implements IDisposable
@rendermode InteractiveWebAssembly

<PageTitle>PoFunQuiz - Game On!</PageTitle>

<!-- Import the separate CSS file for mobile styles -->
<link href="css/gameboard-mobile.css" rel="stylesheet" />

<div class="game-page">
    @if (GameState.CurrentGame == null ||
         GameState.CurrentGame.Player1Questions == null ||
         GameState.CurrentGame.Player2Questions == null)
    {
        <div class="rz-display-flex rz-flex-column rz-align-items-center rz-justify-content-center" style="height: 85vh;">
            <RadzenText TextStyle="TextStyle.H4" class="rz-mb-4">Game session not ready.</RadzenText>
            <RadzenButton ButtonStyle="ButtonStyle.Primary" Path="/">Return to Main Menu</RadzenButton>
        </div>
    }
    else
    {
        <div @onkeydown="HandleKeyDown" tabindex="0" @ref="gameContainer" id="gameContainer" @onclick="FocusGameContainer" class="game-container">
            <div class="rz-p-2 rz-mt-2">
                <!-- Game Timer and Score Info -->
                <RadzenRow>
                    <RadzenColumn Size="12">
                        <RadzenCard class="rz-display-flex rz-justify-content-space-between rz-align-items-center rz-p-2 rz-mb-2" Style="background: linear-gradient(to right, #6a11cb, #2575fc); color: white;">
                            <RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center">
                                <RadzenIcon Icon="timer" class="rz-mr-2" />
                                <RadzenText TextStyle="TextStyle.Body1" class="@GetTimerClass()">
                                    @TimeRemaining s
                                </RadzenText>
                            </RadzenStack>
                            <RadzenStack Orientation="Orientation.Horizontal" Gap="4">
                                <div class="rz-text-align-center">
                                    <RadzenText TextStyle="TextStyle.Caption">P1 Streak: @GameState.CurrentGame.Player1Streak</RadzenText>
                                    <RadzenText TextStyle="TextStyle.Caption">Score: @GameState.CurrentGame.Player1Score</RadzenText>
                                </div>
                                <div class="rz-text-align-center">
                                    <RadzenText TextStyle="TextStyle.Caption">P2 Streak: @GameState.CurrentGame.Player2Streak</RadzenText>
                                    <RadzenText TextStyle="TextStyle.Caption">Score: @GameState.CurrentGame.Player2Score</RadzenText>
                                </div>
                            </RadzenStack>
                        </RadzenCard>
                    </RadzenColumn>
                </RadzenRow>

                <!-- Player Boards -->
                <RadzenRow Gutters="true">
                    <!-- Player 1 Board -->
                    <RadzenColumn Size="12" SizeMD="6" class="@(GetPlayerColumnClass(Player1HasFinished) + " rz-mb-3 rz-mb-md-0")">
                        <RadzenCard class="rz-p-4">
                            <RadzenText TextStyle="TextStyle.H6" class="rz-text-primary rz-mb-2 rz-display-flex rz-align-items-center">
                                @GameState.CurrentGame.Player1.Initials
                                @if (GameState.CurrentGame.Player1Streak >= 3)
                                {
                                    <RadzenIcon Icon="whatshot" class="rz-text-danger rz-ml-1" />
                                }
                            </RadzenText>

                            @if (Player1QuestionIndex < GameState.CurrentGame.Player1Questions.Count)
                            {
                                var question = GameState.CurrentGame.Player1Questions[Player1QuestionIndex];
                                <div class="question-container">
                                    <RadzenText class="rz-mb-4">@question.Question</RadzenText>
                                    <div class="options-grid">
                                        @for (int i = 0; i < question.Options.Count; i++)
                                        {
                                            var index = i;
                                            <div class="option-item @GetAnswerItemClass(1, index)"
                                                 @onclick="@(async () => await LogAndHandle(1, index))">
                                                <span class="option-number">@(i + 1)</span>
                                                <span class="option-text">@question.Options[i]</span>
                                            </div>
                                        }
                                    </div>
                                </div>
                            }
                            else if (!Player1HasFinished)
                            {
                                 <RadzenText>Waiting for questions or game to end...</RadzenText>
                            }
                            else
                            {
                                <RadzenText>Player 1 has finished!</RadzenText>
                            }
                        </RadzenCard>
                    </RadzenColumn>

                    <!-- Player 2 Board -->
                    <RadzenColumn Size="12" SizeMD="6" class="@GetPlayerColumnClass(Player2HasFinished)">
                        <RadzenCard class="rz-p-4">
                            <RadzenText TextStyle="TextStyle.H6" class="rz-text-secondary rz-mb-2 rz-display-flex rz-align-items-center">
                                @GameState.CurrentGame.Player2.Initials
                                @if (GameState.CurrentGame.Player2Streak >= 3)
                                {
                                    <RadzenIcon Icon="whatshot" class="rz-text-danger rz-ml-1" />
                                }
                            </RadzenText>

                            @if (Player2QuestionIndex < GameState.CurrentGame.Player2Questions.Count)
                            {
                                var question = GameState.CurrentGame.Player2Questions[Player2QuestionIndex];
                                <div class="question-container">
                                    <RadzenText class="rz-mb-4">@question.Question</RadzenText>
                                    <div class="options-grid">
                                        @for (int i = 0; i < question.Options.Count; i++)
                                        {
                                            var index = i;
                                            <div class="option-item @GetAnswerItemClass(2, index)"
                                                 @onclick="@(async () => await LogAndHandle(2, index))">
                                                <span class="option-number">@(i + 1)</span>
                                                <span class="option-text">@question.Options[i]</span>
                                            </div>
                                        }
                                    </div>
                                </div>
                            }
                             else if (!Player2HasFinished)
                            {
                                 <RadzenText>Waiting for questions or game to end...</RadzenText>
                            }
                            else
                            {
                                <RadzenText>Player 2 has finished!</RadzenText>
                            }
                        </RadzenCard>
                    </RadzenColumn>
                </RadzenRow>
            </div>
        </div>
    }
</div>

<style>
    /* --- Animation Styles --- */
    @@keyframes correctAnswerFlash {
      0%, 100% { background-color: var(--rz-base-300); transform: scale(1); } /* Subtle background */
      50% { background-color: var(--rz-success); color: white; transform: scale(1.03); } /* Flash success color */
    }

    @@keyframes incorrectAnswerShake {
      0%, 100% { background-color: var(--rz-base-300); transform: translateX(0); } /* Subtle background */
      10%, 30%, 50%, 70%, 90% { background-color: var(--rz-danger); color: white; transform: translateX(-3px); } /* Flash error color and shake */
      20%, 40%, 60%, 80% { background-color: var(--rz-danger); color: white; transform: translateX(3px); }
    }

    @@keyframes timerPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    .correct-answer-flash {
      animation: correctAnswerFlash 0.4s ease-in-out;
    }

    .incorrect-answer-shake {
      animation: incorrectAnswerShake 0.4s ease-in-out;
    }

    .timer-pulse {
        animation: timerPulse 1s infinite ease-in-out;
    }

    .score-text {
        transition: color 0.3s ease, transform 0.3s ease;
    }
    /* --- End Animation Styles --- */

    .game-page {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        padding-bottom: 20px; /* Ensure space for content at the bottom */
    }
    
    .game-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: auto; /* Allow scrolling if content overflows */
        outline: none; /* Remove default focus outline */
    }
        
    .selected-option { /* This class might be redundant if GetAnswerItemClass handles all states */
        background-color: var(--rz-secondary-lighter); /* Example Radzen selection color */
    }
        
    .question-container {
        min-height: 200px; /* Adjust as needed */
    }

    .options-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem; /* Or var(--rz-spacing-3) or similar */
    }

    .option-item {
        position: relative;
        padding: 1rem; /* Or var(--rz-spacing-3) or similar */
        border: 1px solid var(--rz-base-400); /* Radzen border color */
        border-radius: var(--rz-border-radius); /* Radzen border radius */
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        min-height: 60px;
        background-color: var(--rz-base-100); /* Radzen default background */
    }

    .option-item:hover {
        background-color: var(--rz-base-200); /* Radzen hover background */
        transform: translateY(-2px);
    }

    .option-item.selected { /* Applied when selected but before feedback */
        background-color: var(--rz-secondary-lighter);
        border-color: var(--rz-secondary);
    }

    .option-item.correct { /* Applied during feedback for correct answer */
        /* Animation handles flash, this can be a fallback or final state if needed */
         border-color: var(--rz-success);
    }

    .option-item.incorrect { /* Applied during feedback for incorrect answer */
        /* Animation handles flash, this can be a fallback or final state if needed */
        border-color: var(--rz-danger);
    }

    .option-number {
        position: absolute;
        top: 0.5rem;
        left: 0.5rem;
        font-size: 0.8rem;
        color: var(--rz-text-disabled-color); /* Radzen disabled/subtle text color */
    }

    .option-text {
        margin-left: 1.5rem; /* Space for the number */
        flex: 1;
    }
    
    .opacity-50 {
        opacity: 0.5;
    }

    @@media (max-width: 600px) {
        .options-grid {
            grid-template-columns: 1fr; /* Single column on small screens */
        }

        .option-item {
            min-height: 50px;
            padding: 0.75rem; /* Adjust padding for smaller screens */
        }
        .rz-p-4 { /* Reduce padding on cards for mobile */
            padding: 0.75rem !important;
        }
    }
</style>

@code {
    private ElementReference gameContainer;
    private Timer? gameTimer;
    private Timer? feedbackTimer;
    private int TimeRemaining { get; set; } = 60;
    private Stopwatch answerStopwatch = new();

    private int Player1QuestionIndex { get; set; } = 0;
    private bool Player1HasFinished { get; set; } = false;
    private bool Player1FeedbackVisible { get; set; } = false;
    private bool Player1LastAnswerCorrect { get; set; } = false;
    private int? Player1JustSelectedAnswerIndex { get; set; } = null;

    private int Player2QuestionIndex { get; set; } = 0;
    private bool Player2HasFinished { get; set; } = false;
    private bool Player2FeedbackVisible { get; set; } = false;
    private bool Player2LastAnswerCorrect { get; set; } = false;
    private int? Player2JustSelectedAnswerIndex { get; set; } = null;

    private string GetTimerClass()
    {
        var classes = new List<string>();
        if (TimeRemaining <= 5) classes.Add("timer-pulse");
        if (TimeRemaining <= 10) classes.Add("rz-text-danger");
        return string.Join(" ", classes);
    }

    private string GetPlayerColumnClass(bool hasFinished)
    {
        return hasFinished ? "opacity-50 " : ""; // Added trailing space
    }

    protected override void OnInitialized()
    {
        Logger.LogInformation("üîµ GameBoard OnInitialized called at {Time}", DateTime.Now);
        base.OnInitialized();
    }

    private async Task FocusGameContainer()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", $"document.getElementById('gameContainer').focus()");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error focusing game container");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogInformation("üîµ GameBoard first render at {Time}", DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss"));
            if (GameState.CurrentGame == null)
            {
                Logger.LogWarning("‚ö†Ô∏è GameState.CurrentGame is null, navigating to home");
                Navigation.NavigateTo("/");
                return;
            }
            await JS.InvokeVoidAsync("eval", $"document.getElementById('gameContainer').focus()");
            StartGameTimer();
            answerStopwatch.Start();
            Logger.LogInformation("‚úÖ GameBoard initialization complete");
        }
    }

    private void StartGameTimer()
    {
        Logger.LogInformation("‚è±Ô∏è StartGameTimer called at {Time}", DateTime.Now);
        gameTimer?.Dispose(); 
        gameTimer = new Timer(1000);
        gameTimer.Elapsed += OnGameTimerElapsed;
        gameTimer.AutoReset = true;
        gameTimer.Start();
        Logger.LogInformation("‚úÖ Game timer successfully started");
    }

    private void OnGameTimerElapsed(object? sender, ElapsedEventArgs e)
    {
        InvokeAsync(() =>
        {
            TimeRemaining--;
            if (TimeRemaining % 5 == 0 || TimeRemaining <= 10)
            {
                Logger.LogInformation("‚è±Ô∏è Timer update: {TimeRemaining} seconds remaining at {Time}", TimeRemaining, DateTime.Now);
            }
            if (TimeRemaining <= 0)
            {
                Logger.LogInformation("‚è±Ô∏è Timer reached zero, ending game");
                EndGame();
            }
            StateHasChanged();
        });
    }

    private string GetAnswerItemClass(int playerNumber, int optionIndex)
    {
        var feedbackVisible = playerNumber == 1 ? Player1FeedbackVisible : Player2FeedbackVisible;
        var lastAnswerCorrect = playerNumber == 1 ? Player1LastAnswerCorrect : Player2LastAnswerCorrect;
        var justSelected = playerNumber == 1 ? Player1JustSelectedAnswerIndex : Player2JustSelectedAnswerIndex;

        if (justSelected == optionIndex)
        {
            if (feedbackVisible)
            {
                return lastAnswerCorrect ? "correct-answer-flash" : "incorrect-answer-shake";
            }
            return "selected";
        }
        return "";
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (GameState.CurrentGame?.Player1Questions == null || GameState.CurrentGame?.Player2Questions == null) return;

        if (!Player1HasFinished && Player1QuestionIndex < GameState.CurrentGame.Player1Questions.Count)
        {
            if (e.Key == "1") HandlePlayerAnswer(1, 0);
            else if (e.Key == "2") HandlePlayerAnswer(1, 1);
            else if (e.Key == "3") HandlePlayerAnswer(1, 2);
            else if (e.Key == "4") HandlePlayerAnswer(1, 3);
        }

        if (!Player2HasFinished && Player2QuestionIndex < GameState.CurrentGame.Player2Questions.Count)
        {
            if (e.Key == "6") HandlePlayerAnswer(2, 0);
            else if (e.Key == "7") HandlePlayerAnswer(2, 1);
            else if (e.Key == "8") HandlePlayerAnswer(2, 2);
            else if (e.Key == "9") HandlePlayerAnswer(2, 3);
        }
    }

    private void HandleTouchAnswer(int playerNumber, int selectedOptionIndex)
    {
        if ((playerNumber == 1 && !Player1HasFinished) || (playerNumber == 2 && !Player2HasFinished))
        {
            HandlePlayerAnswer(playerNumber, selectedOptionIndex);
        }
    }

    private void HandlePlayerAnswer(int playerNumber, int selectedOptionIndex)
    {
        Logger.LogInformation("HandlePlayerAnswer called for player {Player} option {Option}", playerNumber, selectedOptionIndex);

        if (GameState.CurrentGame == null)
        {
            Logger.LogWarning("HandlePlayerAnswer: GameState.CurrentGame is null");
            return;
        }

        if ((playerNumber == 1 && Player1FeedbackVisible) || (playerNumber == 2 && Player2FeedbackVisible))
        {
            Logger.LogInformation("HandlePlayerAnswer: feedback visible for player {Player}, ignoring input", playerNumber);
            return;
        }

        var elapsedSeconds = answerStopwatch.Elapsed.TotalSeconds;
        var speedMultiplier = CalculateSpeedMultiplier(elapsedSeconds);
        Logger.LogInformation("Answer elapsedSeconds={ElapsedSeconds} speedMultiplier={Speed}", elapsedSeconds, speedMultiplier);

        if (playerNumber == 1)
        {
            if (Player1QuestionIndex >= GameState.CurrentGame.Player1Questions.Count)
            {
                Logger.LogInformation("Player1QuestionIndex {Index} >= question count {Count}", Player1QuestionIndex, GameState.CurrentGame.Player1Questions.Count);
                return;
            }

            var currentQuestion = GameState.CurrentGame.Player1Questions[Player1QuestionIndex];
            Player1LastAnswerCorrect = selectedOptionIndex == currentQuestion.CorrectOptionIndex;
            Player1FeedbackVisible = true;
            Player1JustSelectedAnswerIndex = selectedOptionIndex;
            GameState.CurrentGame.AddAnswer(1, Player1LastAnswerCorrect, currentQuestion.BasePoints, speedMultiplier);

            Logger.LogInformation("Player 1 answered. Correct={Correct}. Index={Index}", Player1LastAnswerCorrect, Player1QuestionIndex);
        }
        else 
        {
            if (Player2QuestionIndex >= GameState.CurrentGame.Player2Questions.Count)
            {
                Logger.LogInformation("Player2QuestionIndex {Index} >= question count {Count}", Player2QuestionIndex, GameState.CurrentGame.Player2Questions.Count);
                return;
            }

            var currentQuestion = GameState.CurrentGame.Player2Questions[Player2QuestionIndex];
            Player2LastAnswerCorrect = selectedOptionIndex == currentQuestion.CorrectOptionIndex;
            Player2FeedbackVisible = true;
            Player2JustSelectedAnswerIndex = selectedOptionIndex;
            GameState.CurrentGame.AddAnswer(2, Player2LastAnswerCorrect, currentQuestion.BasePoints, speedMultiplier);

            Logger.LogInformation("Player 2 answered. Correct={Correct}. Index={Index}", Player2LastAnswerCorrect, Player2QuestionIndex);
        }
        
        ShowFeedbackThenAdvance(playerNumber);
        answerStopwatch.Restart();
        StateHasChanged();
    }

    private double CalculateSpeedMultiplier(double elapsedSeconds)
    {
        return elapsedSeconds switch
        {
            <= 2.0 => 2.0, <= 4.0 => 1.5, <= 6.0 => 1.25, _ => 1.0
        };
    }

    private void ShowFeedbackThenAdvance(int playerNumber)
    {
        feedbackTimer?.Dispose();
        feedbackTimer = new Timer(700); 
        feedbackTimer.Elapsed += (_, _) =>
        {
            InvokeAsync(() =>
            {
                if (GameState.CurrentGame == null) return;

                if (playerNumber == 1)
                {
                    Player1FeedbackVisible = false;
                    Player1JustSelectedAnswerIndex = null;
                    Player1QuestionIndex++;
                    if (Player1QuestionIndex >= GameState.CurrentGame.Player1Questions.Count)
                    {
                        Player1HasFinished = true;
                        CalculateTimeBonus(1);
                    }
                }
                else 
                {
                    Player2FeedbackVisible = false;
                    Player2JustSelectedAnswerIndex = null;
                    Player2QuestionIndex++;
                    if (Player2QuestionIndex >= GameState.CurrentGame.Player2Questions.Count)
                    {
                        Player2HasFinished = true;
                        CalculateTimeBonus(2);
                    }
                }

                if (Player1HasFinished && Player2HasFinished)
                {
                    EndGame();
                }
                else
                {
                    StateHasChanged();
                }
            });
        };
        feedbackTimer.AutoReset = false;
        feedbackTimer.Start();
    }
    
    private void CalculateTimeBonus(int playerNumber)
    {
        if (GameState.CurrentGame == null) return;
        int effectiveTimeRemaining = Math.Max(0, TimeRemaining);
        int bonus = Math.Min(3, (int)Math.Ceiling(effectiveTimeRemaining / 20.0));
        
        if (playerNumber == 1) {
            GameState.CurrentGame.Player1TimeBonus = bonus;
        } else {
            GameState.CurrentGame.Player2TimeBonus = bonus;
        }
        Logger.LogInformation($"Player {playerNumber} time bonus: {bonus} for {effectiveTimeRemaining}s left.");
        StateHasChanged(); 
    }

    private void EndGame()
    {
        gameTimer?.Stop();
        feedbackTimer?.Stop(); 
        if (GameState.CurrentGame == null) return;
        GameState.CurrentGame.EndTime = DateTime.UtcNow;
        Logger.LogInformation("üèÅ Game ended at {Time}. Navigating to results.", GameState.CurrentGame.EndTime);
        Navigation.NavigateTo("/results", forceLoad: true);
    }

    [JSInvokable]
    public void HandleSwipe(string direction)
    {
        Logger.LogInformation("Swipe detected: {Direction}", direction);
    }

    private async Task LogAndHandle(int playerNumber, int index)
    {
        try
        {
            // Log to browser console immediately so we can see the click in captured console logs
            await JS.InvokeVoidAsync("console.log", $"""Option clicked: player {playerNumber} index {index}""");
        }
        catch
        {
            // ignore JS interop errors
        }

        // Call the existing touch handler
        HandleTouchAnswer(playerNumber, index);
    }

    public void Dispose()
    {
        Logger.LogInformation("‚ôªÔ∏è Disposing GameBoard component at {Time}", DateTime.Now);
        gameTimer?.Dispose();
        feedbackTimer?.Dispose();
    }
}
